---
title: AWS ALB 마이그레이션 - Haproxy Active-Passive 구성(feat. Keepalived)
date: 2025-07-31
modified: 2025-07-31
tags: [project]
description: ALB 마이그레이션 메모
image: ""
usemathjax: true
---

> ALB와 Public Ipv4 비용을 절감하기 위해 Haproxy + Keepalived Active Passive 구성으로 마이그레이션하기로 결정했다.

## 1. 사전 작업

```bash
# 타임존 설정
sudo timedatectl set-timezone Asia/Seoul

# haproxy + keepalived
sudo apt-get update
sudo apt-get install haproxy
sudo apt-get install keepalived

# 인증서 및 설정 동기화 자동화
sudo apt install inotify-tools

# certbot
sudo snap install core
sudo snap refresh core
sudo snap install --classic certbot
sudo ln -s /snap/bin/certbot /usr/bin/certbot

# aws cli
sudo apt-get install unzip
curl "https://awscli.amazonaws.com/awscli-exe-linux-aarch64.zip" -o "awscliv2.zip"
unzip awscliv2.zip
sudo ./aws/install
```

## 2. Haproxy 설정

- 설정 파일 : /etc/haproxy/haproxy.cfg 
- 로그 파일 : /var/log/haproxy.log

```
global
	log /dev/log	local0
	log /dev/log	local1 notice
	chroot /var/lib/haproxy
	stats socket /run/haproxy/admin.sock mode 660 level admin
	stats timeout 30s
	user haproxy
	group haproxy
	daemon

	maxconn 2048
    	# https://cbonte.github.io/haproxy-dconv/configuration-1.5.html#3.2-tune.ssl.default-dh-param
    	# bit setting for Diffie - Hellman key size.
    	tune.ssl.default-dh-param 2048

	# Default SSL material locations
	ca-base /etc/ssl/certs
	crt-base /etc/ssl/private

	# See: https://ssl-config.mozilla.org/#server=haproxy&server-version=2.0.3&config=intermediate
        ssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384
        ssl-default-bind-ciphersuites TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256
        ssl-default-bind-options ssl-min-ver TLSv1.2 no-tls-tickets

defaults
	log	global
	mode	http
	option	httplog
	option	dontlognull
        timeout connect 5000
        timeout client  50000
        timeout server  50000
	errorfile 400 /etc/haproxy/errors/400.http
	errorfile 403 /etc/haproxy/errors/403.http
	errorfile 408 /etc/haproxy/errors/408.http
	errorfile 500 /etc/haproxy/errors/500.http
	errorfile 502 /etc/haproxy/errors/502.http
	errorfile 503 /etc/haproxy/errors/503.http
	errorfile 504 /etc/haproxy/errors/504.http

# Haproxy Dashboard - 관리자 IP 대역만 접근할 수 있도록 SG 설정 필요
frontend stats
        bind *:8404
        stats enable
        stats uri /
        stats refresh 10s

# HTTP
frontend http-api.maeil-mail.kr
        bind *:80
        http-request set-header X-Forwarded-Proto http
        default_backend apps

# HTTPS
frontend https-api.maeil-mail.kr
        bind *:443 ssl crt /etc/haproxy/certs/site.pem
        http-request set-header X-Forwarded-Proto https
        http-request set-header X-SSL %[ssl_fc]
        acl letsencrypt-acl path_beg /.well-known/acme-challenge/
        use_backend letsencrypt-backend if letsencrypt-acl
        default_backend apps

# APPS
backend apps
        redirect scheme https code 301 if !{ ssl_fc }
        balance roundrobin
        server mm-app-1 172.31.82.62:8080 check
        server mm-app-2 172.31.98.184:8080 check

# 인증서 발급 및 갱신 - HTTPS의 ACL letsencrypt-acl 설정 확인
# Letsencrypt
backend letsencrypt-backend
        server letsencrypt 127.0.0.1:9090
```

## 3. Keepalived 구성

- 설정 파일 : /etc/keepalived/keepalived.conf
- 로그 파일 : /var/log/syslog

active 설정

```
global_defs {
    log_global
    router_id maeilmail-rt-active
    script_user root
}

vrrp_script check_haproxy {
    script "pidof haproxy"
    interval 5
    fall 2
    rise 2
}

vrrp_instance VI_1 {
    interface ens5
    state MASTER
    virtual_router_id 50
    advert_int 3
    nopreempt
    priority 110
    unicast_src_ip 172.31.27.180

    authentication {
        auth_type PASS
	    auth_pass testpassword
    }

    unicast_peer {
        172.31.34.184
    }

    track_script {
        check_haproxy
    }

    notify_master /etc/keepalived/failover.sh
}
```

passive 설정

```
global_defs {
    log_global
    router_id maeilmail-rt-passive
    script_user root
}

vrrp_script check_haproxy {
    script "pidof haproxy"
    interval 5
    fall 2
    rise 2
}

vrrp_instance VI_1 {
    interface ens5
    state BACKUP
    virtual_router_id 50
    advert_int 3
    nopreempt
    priority 100
    unicast_src_ip 172.31.34.184

    authentication {
        auth_type PASS
        auth_pass testpassword
    }

    unicast_peer {
        172.31.27.180
    }

    track_script {
        check_haproxy
    }

    notify_master /etc/keepalived/failover.sh
}
```

failover 스크립트(failover.sh)

```bash
#!/bin/bash

EIP= # EIP
INSTANCE_ID= # 인스턴스 ID
/usr/bin/aws ec2 disassociate-address --public-ip $EIP
/usr/bin/aws ec2 associate-address --public-ip $EIP --instance-id $INSTANCE_ID
```

## 4. SSL 설정

인증서 발급, fullchain.pem이랑 privkey.pem을 합쳐서 site.pem으로 만들어야한다.

```bash
sudo certbot certonly \
    --webroot \ 
    --agree-tos 
    -m team.maeilmail@gmail.com \
    -w /var/www/letsencrypt \
    -d test.maeil-mail.kr \ 
    --http-01-port=9090

DOMAIN='test.maeil-mail.kr' sudo -E bash -c 'cat /etc/letsencrypt/live/$DOMAIN/fullchain.pem /etc/letsencrypt/live/$DOMAIN/privkey.pem > /etc/haproxy/certs/site.pem'
```

아래는 certbot renew 타이머 정보를 조회하는 방법이다.

```bash
# certbot renew 타이머 정보 조회
systemctl cat snap.certbot.renew.timer

# 다음 renew 실행 시간 조회
systemctl list-timers | grep certbot
```

renew 할때마다 fullchain.pem이랑 privkey.pem 합쳐야해서 deploy hook 사용해야한다.

/etc/letsencrypt/renewal-hooks/deploy/haproxy-pem-hook.sh

```bash
#!/bin/bash

DOMAIN="test.maeil-mail.kr"
TARGET_PEM="/etc/haproxy/certs/site.pem"
CERT="/etc/letsencrypt/live/$DOMAIN"

cat $CERT/fullchain.pem $CERT/privkey.pem > $TARGET_PEM

echo "$TARGET_PEM generated."

systemctl reload haproxy
```

스크립트 실행되는지 실행하려면 강제 리뉴얼로 테스트

```bash
sudo certbot renew --force-renewal
```

## 5. 설정 동기화

/home/ubuntu/sync/watch_sync.sh

```bash
#!/bin/bash
WATCH_DIRS="/etc/haproxy /etc/haproxy/certs"
PIPE="/tmp/haproxy-pipe"
LOG_FILE="./log/haproxy-sync.log"
REMOTE_USER="ubuntu"
REMOTE_HOST="172.31.34.184"
INOTIFY_PID=0

cleanup() {
  echo "$(date) - cleanup() called, killing $INOTIFY_PID" >> "$LOG_FILE"
  [[ $INOTIFY_PID -gt 0 ]] && kill $INOTIFY_PID 2>/dev/null
  rm -f "$PIPE"
  exit 0
}
trap cleanup SIGINT SIGTERM EXIT

[[ -p "$PIPE" ]] && rm -f "$PIPE"
mkfifo "$PIPE"

echo "$(date) - File Sync Started, main PID = $$" >> "$LOG_FILE"

inotifywait -mrq -e close_write $WATCH_DIRS > "$PIPE" &
INOTIFY_PID=$!

while read path action file;  do
 echo "$(date) - Detected $action on $path$file" >> "$LOG_FILE"

  if [ "$file" = "haproxy.cfg" ]; then
    scp -p /etc/haproxy/haproxy.cfg $REMOTE_USER@$REMOTE_HOST:/home/ubuntu/tmp/ >> "$LOG_FILE"
    ssh $REMOTE_USER@$REMOTE_HOST "sudo mv /home/ubuntu/tmp/haproxy.cfg /etc/haproxy/ && sudo systemctl reload haproxy" >> "$LOG_FILE"
  fi

  if [ "$file" = "site.pem" ]; then
    scp -p /etc/haproxy/certs/site.pem $REMOTE_USER@$REMOTE_HOST:/home/ubuntu/tmp/ >> "$LOG_FILE"
    ssh $REMOTE_USER@$REMOTE_HOST "sudo mv /home/ubuntu/tmp/site.pem /etc/haproxy/certs/ && sudo systemctl reload haproxy" >> "$LOG_FILE"
  fi
done < "$PIPE"
```

- active-passive 노드 간 site.pem이랑 haproxy 동기화를 위해서 inotifywait으로 감시한다.
- close_wait만 감지하도록 설정하고, if로 haproxy.cfg랑 site.pem이 변경되면 백업 노드로 전송한다.
    - 이거 하려면, passive 노드에 해당 경로에 대한 디렉터리를 미리 만들어야 하고..
    - active 노드의 public key를 passive node ~/.ssh/authorized_keys에 추가해야한다.
- 스크립트 프로세스에 SIGINT SIGTERM 신호 받으면 트랩으로 inotify 프로세스랑 네임드 파이프를 정리한다. (inotifywait 종료안돼서.. 진짜 골치아팠다..)
- 위에 renewal-hook이랑 마찬가지로 항상 설정을 바꾸면 reload 시켜야한다.
- 입력 리디렉션으로 while에 inotifywait 출력 줘야한다.
- 로그는 /home/ubuntu/sync/log/haproxy-sync.log에 쌓았다.
